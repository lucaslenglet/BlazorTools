@using System.Diagnostics

@implements IDisposable

@inject ILogger<Button> Logger

@{
    Logger.LogRender(this.GetHashCode());
}

<button class="btn btn-@Style.ToString()" @onclick="OnClickInternal" disabled=@disabled title="@lastExecutionTime">
    @if (!string.IsNullOrWhiteSpace(Value))
    {
        @Value
    }
    else
    {
        @ChildContent
    }
</button>

@code {
    [Parameter,]
    public EventCallback OnClick { get; set; }

    [Parameter]
    public string? Value { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public ButtonStyle? Style { get; set; } = ButtonStyle.primary;

    [Parameter, CascadingParameter]
    public EventCallbackBucket? OnDisableToggled { get; set; }

    private bool disabled = false;
    private string? lastExecutionTime;
    private EventSubscription eventSubscription = new();

    public enum ButtonStyle
    {
        primary,
        secondary,
        danger
    }

    protected override void OnInitialized()
    {
        if (OnDisableToggled is not null)
        {
            OnDisableToggled.Subscribe(eventSubscription , () => ToggleDisable(true));
        }
    }

    private async Task OnClickInternal()
    {
        if (!OnClick.HasDelegate || disabled)
        {
            return;
        }

        // await ToggleDisable(); // 3

        // await using var _ = LockerBuilder.Create(HttpContext)
        //     .MinimumTime(TimeSpan.FromMilliseconds(500))
        //     .ToggleDisableUsing(ToggleDisable)
        //     .Build(); // 3

        await using var _ = await LockerBuilder.Create()
            .MinimumTime(TimeSpan.FromMilliseconds(500))
            .ToggleDisableUsing(SmartToggleDisable)
            .BuildAndToggle(); // 4

        // var minExecTime = MinExecTime.FromNow(500); // 1

        // await using var toggleDisable = DeferedExecutionAsync.For(ToggleDisable); // 2
        // var execution = DeferedExecutionAsync.For(MinimumExecutionTime.FromNowAtLeast(milliseconds: 500), min => min.WaitIfUnder(HttpContext?.RequestAborted ?? default)); // 2

        await OnClick.InvokeAsync();

        // await minExecTime.WaitIfUnder(); // 1
        // await ToggleDisable(); // 1

        // await execution.DisposeAsync(); // 2

        // var fullExecTime = Stopwatch.GetElapsedTime(execution.Value.Start).TotalSeconds; // 2
        // lastExecutionTime = $"Last exection took {fullExecTime}s"; // 2
    }

    private async Task SmartToggleDisable()
    {
        await ToggleDisable(false);

        if (OnDisableToggled is not null)
        {
            await OnDisableToggled.InvokeExceptAsync(eventSubscription);
        }
    }

    private async Task ToggleDisable(bool forceRender)
    {
        disabled = !disabled;

        if (disabled || forceRender)
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        if (OnDisableToggled is not null)
        {
            OnDisableToggled.Unsubscribe(eventSubscription);
        }
    }

    public class Locker : IAsyncDisposable
    {
        private DeferedExecutionAsync? deferedToggleDisable;
        private DeferedExecutionAsync<MinimumExecutionTime>? deferedMinimumTimeExecution;
        private CancellationToken cancellationToken;
        private bool isDisposingOrDisposed = false;
        private readonly Lock _lock = new();

        public Locker(TimeSpan? minimumTime, Func<Task>? toggleDisable, CancellationToken cancellationToken)
        {
            this.cancellationToken = cancellationToken;

            if (toggleDisable is not null)
            {
                deferedToggleDisable = DeferedExecutionAsync.For(
                    func: toggleDisable);
            }

            if (minimumTime is not null)
            {
                deferedMinimumTimeExecution = DeferedExecutionAsync.For(
                    value: MinimumExecutionTime.FromNowAtLeast(minimumTime.Value),
                    func: min => min.WaitIfUnder(cancellationToken));
            }
        }

        public async ValueTask DisposeAsync()
        {
            lock (_lock)
            {
                if (isDisposingOrDisposed)
                {
                    return;
                }

                isDisposingOrDisposed = true;
            }

            if (deferedMinimumTimeExecution is not null)
            {
                await deferedMinimumTimeExecution.DisposeAsync();
            }

            if (deferedToggleDisable is not null)
            {
                await deferedToggleDisable.DisposeAsync();
            }
        }
    }

    public class LockerBuilder(CancellationToken cancellationToken = default)
    {
        private TimeSpan? minimumTime;
        private Func<Task>? toggleDisable;
        private CancellationToken cancellationToken = cancellationToken;

        public static LockerBuilder Create() => new();
        public static LockerBuilder Create(HttpContext? httpContext) => new(httpContext?.RequestAborted ?? default);
        public static LockerBuilder Create(CancellationToken cancellationToken) => new(cancellationToken);

        public LockerBuilder MinimumTime(TimeSpan minimumTime)
        {
            this.minimumTime = minimumTime;
            return this;
        }

        public LockerBuilder ToggleDisableUsing(Func<Task> toggleDisable)
        {
            this.toggleDisable = toggleDisable;
            return this;
        }

        public Locker Build() => new(minimumTime, toggleDisable, cancellationToken);

        public async Task<Locker> BuildAndToggle()
        {
            ArgumentNullException.ThrowIfNull(toggleDisable);

            await toggleDisable.Invoke();

            return Build();
        }
    }
}
