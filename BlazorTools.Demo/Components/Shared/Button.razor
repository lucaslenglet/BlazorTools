@using System.Diagnostics

@inject ILogger<Button> Logger

@{
    Logger.LogRender(this.GetHashCode());
}

<button class="btn btn-@Style.ToString()" @onclick="OnClickInternal" disabled=@disabled title="@lastExecutionTime">
    @if (!string.IsNullOrWhiteSpace(Value))
    {
        @Value
    }
    else
    {
        @ChildContent
    }
</button>

@code {
    [Parameter, ]
    public EventCallback OnClick { get; set; }

    [Parameter]
    public string? Value { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    [Parameter]
    public ButtonStyle? Style { get; set; } = ButtonStyle.primary;

    [CascadingParameter]
    public HttpContext? HttpContext { get; set; }

    private bool disabled = false;
    private string? lastExecutionTime;

    public enum ButtonStyle
    {
        primary,
        secondary,
        danger
    }

    private async Task OnClickInternal()
    {
        if (!OnClick.HasDelegate || disabled)
        {
            return;
        }

        await ToggleDisable();
        // var minExecTime = MinExecTime.FromNow(500);

        await using var toggleDisable = DeferedExecutionAsync.For(ToggleDisable);
        var execution = DeferedExecutionAsync.For(MinimumExecutionTime.FromNowAtLeast(milliseconds: 500), min => min.WaitIfUnder(HttpContext?.RequestAborted ?? default));

        await OnClick.InvokeAsync();

        // await minExecTime.WaitIfUnder();
        // await ToggleDisable();

        await execution.DisposeAsync();

        var fullExecTime = Stopwatch.GetElapsedTime(execution.Value.Start).TotalSeconds;
        lastExecutionTime = $"Last exection took {fullExecTime}s";
    }

    private async Task ToggleDisable()
    {
        if (disabled)
        {
            disabled = false;
            return;
        }

        disabled = true;
        await InvokeAsync(StateHasChanged);
    }
}
